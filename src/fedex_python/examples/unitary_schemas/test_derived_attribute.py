# This file was generated by fedex_python.  You probably don't want to edit
# it since your modifications will be lost if fedex_plus is used to
# regenerate it.
from SCL.SCLBase import *
from SCL.SimpleDataTypes import *
from SCL.ConstructedDataTypes import *
from SCL.AggregationDataType import *
from SCL.TypeChecker import check_type
from SCL.Expr import *

####################
 # ENTITY vector #
####################
class vector(BaseEntityClass):
	'''Entity vector definition.

	:param x
	:type x:REAL

	:param y
	:type y:REAL
	'''
	def __init__( self , x,y, ):
		self.x = x
		self.y = y

	@apply
	def x():
		def fget( self ):
			return self._x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument x is mantatory and can not be set to None')
			check_type(value,REAL)
			self._x = value
		return property(**locals())

	@apply
	def y():
		def fget( self ):
			return self._y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument y is mantatory and can not be set to None')
			check_type(value,REAL)
			self._y = value
		return property(**locals())

####################
 # ENTITY circle #
####################
class circle(BaseEntityClass):
	'''Entity circle definition.

	:param centre
	:type centre:point

	:param radius
	:type radius:REAL

	:param axis
	:type axis:vector

	:param area
	:type area:REAL

	:param perimeter
	:type perimeter:REAL
	'''
	def __init__( self , centre,radius,axis, ):
		self.centre = centre
		self.radius = radius
		self.axis = axis

	@apply
	def centre():
		def fget( self ):
			return self._centre
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument centre is mantatory and can not be set to None')
			check_type(value,point)
			self._centre = value
		return property(**locals())

	@apply
	def radius():
		def fget( self ):
			return self._radius
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument radius is mantatory and can not be set to None')
			check_type(value,REAL)
			self._radius = value
		return property(**locals())

	@apply
	def axis():
		def fget( self ):
			return self._axis
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument axis is mantatory and can not be set to None')
			check_type(value,vector)
			self._axis = value
		return property(**locals())

	@apply
	def area():
		def fget( self ):
			return EvalDerivedAttribute(self,'''PI * (radius ** 2)''')
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument area is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

	@apply
	def perimeter():
		def fget( self ):
			return EvalDerivedAttribute(self,'''2 * PI * radius''')
		def fset( self, value ):
		# DERIVED argument
			raise AssertionError('Argument perimeter is DERIVED. It is computed and can not be set to any value')
		return property(**locals())

####################
 # ENTITY point #
####################
class point(BaseEntityClass):
	'''Entity point definition.

	:param x
	:type x:REAL

	:param y
	:type y:REAL

	:param z
	:type z:REAL
	'''
	def __init__( self , x,y,z, ):
		self.x = x
		self.y = y
		self.z = z

	@apply
	def x():
		def fget( self ):
			return self._x
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument x is mantatory and can not be set to None')
			check_type(value,REAL)
			self._x = value
		return property(**locals())

	@apply
	def y():
		def fget( self ):
			return self._y
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument y is mantatory and can not be set to None')
			check_type(value,REAL)
			self._y = value
		return property(**locals())

	@apply
	def z():
		def fget( self ):
			return self._z
		def fset( self, value ):
		# Mandatory argument
			if value==None:
				raise AssertionError('Argument z is mantatory and can not be set to None')
			check_type(value,REAL)
			self._z = value
		return property(**locals())
